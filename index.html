<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>CG mini-paint</title>
    <script src="libs/d3.js"></script>
    <script src="libs/jquery.js"></script>
    <script src="functions/main.js"></script>
</head>
<body>
<style>
    body{
        background-color: darkgrey;
    }
    svg{
        background-color: white;
    }
</style>
    <svg width="600px" height="600px"></svg>
<script>
        let svg = d3.select("svg");
        let tam = 10;
        let color = "black";

        // canvas();
        // draw_pixel(100,20);
        // draw_pixel(500,250);

        //bresenham(0, 0,  600, 600);
        // bresenham(600, 0,  0, 600);
        // bresenham(300, 0,  300, 600);
        // bresenham(0, 300,  600, 300);
        //
        // MidpointCircle(280,300,300);
        let x = 0;
        while(x<600){
            for(let y = 0;y<600;y+=10){
                svg.append("rect")
                    .attr("width",10)
                    .attr("height",10)
                    .attr("x",x)
                    .attr("y",y)
                    .attr("id",x+","+y)
                    .attr("fill","white")
                    .attr("stroke","black")
                    .attr("stroke-width","0.2px");

            }
            x+=10;
        }

        // let a, b;
        // a = 20;
        // b = 50;
        //
        // let  teste = d3.select('[id=",id10,20"]');
        // console.log(d3.select('[id=",id10,20"]'));
        // console.log(teste);


        let width = 500;
        let height = 500;
        // let postionX ;
        // let postionX ;
        // let color;



        // class  frammeBuffer {
        //     constructor(width, height) {
        //         this.matriz = [];
        //         this.width = width;
        //         this.height = height;
        //
        //     }
        //
        //     static matriz() {
        //         let x = 0;
        //         while(x<this.width){
        //             this.matriz.push(x);
        //             for(let y = 0;y<this.height;y+=10){
        //                 this.matriz[x].push(y);
        //             }
        //             x+=10;
        //         }
        //         console.log(this.matriz);
        //         return this.matriz;
        //
        //     }
        //
        //     }

        // let p1 = new frammeBuffer(width, height);
        //
        // p1.matriz();



        function draw_pixel(x,y){
            let pixel = svg.append("rect")
                .attr("x",x)
                .attr("y",y)
                .attr("width",1)
                .attr("height",1)
                .attr("fill",color);

            return pixel;
        }
        
        // function bresenham( x1, y1,  x2, y2){
        //     let slope;
        //     let dx, dy, incE, incNE, d, x, y;
        //     if (x1 > x2){
        //         bresenham(x2, y2, x1, y1);
        //         return;
        //     }
        //
        //     dx = x2 - x1;
        //     dy = y2 - y1;
        //
        //     if (dy < 0){
        //         slope = -1;
        //         dy = -dy;
        //     }
        //     else{
        //         slope = 1;
        //     }
        //
        //
        //     // Constante de Bresenham
        //     incE = 1 * dy;
        //     incNE = 1 * dy - 1 * dx;
        //     d = 1 * dy - dx;
        //     y = y1;
        //     if(x1===x2){
        //         for (y = y1; y <= y2; y++){
        //             draw_pixel(x1, y);
        //                 y += slope;
        //
        //         }
        //
        //     }
        //     for (x = x1; x <= x2; x++){
        //         draw_pixel(x, y);
        //         if (d <= 0){
        //             d += incE;
        //         }
        //         else{
        //             d += incNE;
        //             y += slope;
        //         }
        //     }
        //
        // }

        function reflection(m,dots) {
            if(!Array.isArray(dots)) return;

            [[x1,y1],[x2,y2]] = dots;
            //              x     y     xy
            let change = [false,false,false];


            if(m>1 || m<-1) {
                let temp = x1;
                x1 = y1
                y1 = temp;

                temp = x2
                x2 = y2
                y2 = temp;

                change[2] = true;
            }

            if(x1 > x2) {
                x1 *=-1
                x2 *=-1
                change[0] = true;
            }

            if(y1 > y2) {
                y1 *=-1
                y2 *=-1
                change[1] = true;
            }

            return [[[x1,y1],[x2,y2]],change];

        }

        function reverse_reflection (m,dots,change) {
            if(!Array.isArray(dots)) return;
            if(!Array.isArray(change)) return;

            let newDots = []

            for (let dot of dots) {
                [x,y] = dot;
                if(change[1]) {y *=-1}

                if(change[0]) {x *=-1}

                if(change[2]) {let temp = x; x = y; y = temp;}
                newDots.push([x,y]);
                draw_pixel(x,y);
            }


            return newDots;
        }

        function bresenham(dots) {
            if(!Array.isArray(dots)) return;

            let m = 0, e = 0;
            [[x1,y1],[x2,y2]] = dots;
            let change = [];

            m = (y2-y1)/(x2-x1);

            //TODO: Avisar que a reflexão não pode ser o primeiro passo, visto que ela depende do m.
            [dots,change] = reflection(m,dots);

            [[x1,y1],[x2,y2]] = dots;

            let x = x1, y = y1;
            m = (y2-y1)/(x2-x1);

            e = m - 0,5;

            let tempdots = [[x,y]]

            while(x < x2) {
                if (e > 0) {y += 1; e -= 1;}
                x += 1; e += m;

                tempdots.push([x, y]);
            }

            return reverse_reflection(m,tempdots,change)
        }


        let points = bresenham([[100,20],[150,500]]);

        console.log( points);





        // function CirclePoints(x, y,vx,vy){
        //     draw_pixel(vx + x,vy + y);
        //     draw_pixel(vx + x,vy +  -y);
        //     draw_pixel(vx + -x,vy +  y);
        //     draw_pixel(vx + -x,vy +  -y);
        //     draw_pixel(vx + y,vy +  x);
        //     draw_pixel(vx + y,vy +  x);
        //     draw_pixel(vx + y,vy +  -x);
        //     draw_pixel(vx + -y,vy + x);
        //     draw_pixel(vx + -y,vy + -x);
        // }

        // function MidpointCircle(radius, valueX,valueY){
        //     let x = 0;
        //     let y = radius;
        //     let d = 1 - radius;
        //
        //     CirclePoints(x,y,valueX,valueY);
        //     while(y > x) {
        //         if (d < 0)
        //             d += 2 * x + 3;
        //         else {
        //             d += 2 * (x - y) + 5;
        //             y--;
        //         }
        //         x++;
        //         CirclePoints(x, y,valueX,valueY);
        //     }
        // }
        //

    // bresenham(10,100,200,300);
    // bresenham(10,100,300,300);
    // bresenham(100,0,100,500);



</script>



</body>
</html>